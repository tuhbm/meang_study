# 변수
* 선언방법  
> ES3
>> var  

> ES6(선언과 동시에 할당할 수 있다.)IE 엣지부터 가능
>> let - 변수  
const - 상수(상수는 변경이 안되므로, 선언하면서 할당을 해야 한다.)  

**자바스크립트에서 할당을 하지않으면, 비어있는값(undefined)가 할당된 것이다.**  
- undefined는 우리가 할당 할수는 있지만 하지않는다.(기본 아무것도 작성하지않으면 자동 할당되기 떄문에!)  
- 인자를 안넘긴것과 언디파인드는 다르다.(할당하지않은것은 갯수를 알수없지만, 언디파인드는 한개를 할당한다 라는 것)  

**식에서 변수를 사용하는이유**
> 값을 지정하는 행위를 한번에 가능하다.  
식별하기 좋다("변수명을 통해 어떠한 값이다." 라는 예측이 가능하다)!!!  
유지보수가 쉽다.  
변하기위해서(맞는말이지만 별로 중요하지않다.)  
변하지않는 변수(상수)가 대부분이고, 변해야하는 값은 극소수이다.

**매직넘버 -> 변수의 값이라고 한다. 그개발자가 지정한 값**

* ex : pa = pa + 5;
>1번.pa를 해석  
2번.우변의 식을 해석해서   
3번.값으로 변경 후   
4번.pa에 할당

**자바스크립트는 좌에서 우로 해석하지만, 할당연산자만 우에서 좌로 해석**

* 복합 대입 연산자(단순 계산 같지만, 실제로는 여러개의 상태의 변화에 대한 시점이 여러개로 구성되어있다.)
> +=, -=, *=, /=  

**한번이라도 문자열을 더할경우 문자열이된다.**

**문자열 연산은 더할때만 가능하다.**

**원칙의 효과는 모두가 지키고있을때 발생한다.(모두가지키고있을때 혼자만 이상이있으면 발견하기 쉽다.)**

# 코드를 작성할때 지켜야하는 원칙
- 중복은 발견하는 즉시 제거한다.(지저분하다. => 중복이 많다.)


* 증감 연산자(기존 아이폰개발에서는 Objective C를 사용하였는데, swift로 변경하였다. swift에는 증감 연산자가 제거 되었다. 이유는 모든 에러의 악의 근원이라고 판단함. '증감연산자는 숙련된 개발자라하더라도 예측이 어렵다.'라고 판단함)

* 배열[array]
> 이름을 하나만 사용하여도 사용이 가능하다

# 자료형 검사
* typeof 가 검사해서 리턴하는 값은 문자열 6가지
> string, number, boolean, object, function, undefined, symbol

* 자바스크립트 실제
> String, Number, Boolean, Object, Null, Undefined, Symbol

**null ->  null이란값(명시적으로 비워둔값) // undefined -> 값이 현재 없는것**

# 강제 형변환
* 문자열숫자에 * 숫자를 연산하면 강제적으로 문자열숫자가 숫자열로 형변환이된다.
* -,*,/는 강제 문자열을 형변환하기 위해 사용한다.

컴퓨터에서 false를 구분하고 나머지는 다 true로 정의된다
> javascript의 false값 -> 0, null, undefined, false, NaN , ''

# 숫자체계
1. 진법
2. 정수, 실수
> parseInt() - 정수화 시킨다.  
  >> parseInt(값,진법)
  
> parseFloat() - 실수화 시킨다.  

**권장방법은 number함수 사용을 하지 말아라.**

3. NaN

# ===, !== 초심자들은 이두가지만 사용하길 권한

**쉬운단어 사용할것(언어를 정복했을때만 사용해라!)**

# 이스케이프 문자열
- 탈출문자(정상적으로 탈출해주는 문자) -> 역슬레시 사용 = 자기참조무결점


* 괄호 한개당 한개의 메모리가 소모(크롬에 괄호만개에 1을 넣으면 죽음!!)

# 제어문
**정상적인(좌->우,위->아래) flow의 흐름을 거슬러 다르게 움직이고 싶을 때 사용**
* (flow) control statement // for value
> flow란?  
>> 메모리에 있는 (값 연산자 값등)을 cpu로 보내 연산한수 값을 다시 메모리에 담아준다.    

> 값에 따른 flow를 (분기)변경한다.

> if문의 기본적인 형태 - if(값) 문  
>> 괄호는 필수, 값은 true or false

